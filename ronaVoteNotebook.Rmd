---
title: "ronaVote"
subtitle: "Ongoing COVID and the 2020 USA Election:\nTime Trends in Correlation among the Cross-section of Counties"
author: "Steven Bhardwaj"
date: '2021-08-04'
output:
  html_document: default
---

#### Importing Libraries
```{r, warning=FALSE, message=FALSE}
library(rmarkdown)
library(data.table)
library(broom)
library(tidyverse)
library(ggdark)
```

#### Import data.
Remove rows where FIPS data is missing.
```{r}
pathRona <- "./data/rona/NYT/us-counties_panel_2021-08-02.csv"
pathVote <- "./data/vote/Harvard/countypres_2000-2020.csv"
pathPop <- "./data/countyData/USDA_PopulationData/PopEst2019.csv"

ronaDays <- fread(pathRona, select = 
                grep("fips|date|cases",
                names(fread(pathRona, nrow = 0L)))) %>%
            rename(casesTot = cases)
popu <- fread(pathPop, select = 
                grep("fips|state|area_name|pop2019",
                names(fread(pathPop, nrow = 0L))))
vote <- fread(pathVote, select = 
                grep("year|party|mode|candidate|county_name|county_fips|candidatevotes|totalvotes",
                names(fread(pathVote, nrow = 0L)))) %>%
            rename(fips = county_fips)

rawData <- list(ronaDays=ronaDays, popu=popu, vote=vote) %>%
    map(function(x) { filter(x, !is.na(fips)) })
rm(pathRona, pathVote, pathPop, ronaDays, popu, vote)
```

#### Organize and clean tall (melted) COVID data:
  Assign a number to each week starting with 2019-12-29.
  Remove excess rows within weeks.
  Make crosswalks to text-label versions of the numeric dates and FIPS.
```{r}
zeroMonday <- as.IDate("2019-12-29")
zeroMondayInt <- as.numeric(zeroMonday)

ronaTall <- rawData[["ronaDays"]] %>%
    mutate(weekNum = (as.numeric(date) - as.numeric(zeroMondayInt)) %/% 7) %>%
    distinct(fips, weekNum, .keep_all = TRUE) %>%
    mutate(weekDate = as.IDate(weekNum * 7, origin=zeroMonday)) %>%
    mutate(week_DateT = paste("T", gsub("-", "_", weekDate), sep="")) %>%
    mutate(fipsText = paste("x", fips, sep = ""))

weekDates <- distinct(ronaTall, week_DateT, weekDate)
fips_fipsText <- distinct(ronaTall, fips, fipsText, .keep_all = FALSE)
```

#### Tidy election data:
Widen -> a column for each major party,
         a row for each FIPS county.
Sum votes for FIPS areas with multiple subareas.
Calculate vote-margins from vote-counts.
```{r}
vote_wide <- rawData[["vote"]] %>%
    filter(year == 2020) %>%
    select(-c(year)) %>%
    filter((candidate != "JO JORGENSEN") & (candidate != "OTHER")) %>% 
    pivot_wider(names_from = party, 
                values_from = candidatevotes,
                id_cols = -c(party, candidatevotes, candidate))  %>%
    group_by(fips) %>%
    summarize(DEMOCRAT = sum(DEMOCRAT),
              REPUBLICAN = sum(REPUBLICAN),
              county_name = unique(county_name), 
              totalvotes = unique(totalvotes)) %>%
    mutate(DJT_Margin = (REPUBLICAN - DEMOCRAT) / (REPUBLICAN + DEMOCRAT))
```

#### Tidy COVID data:
Widen -> a column for each week
         a row for each FIPS county.
Join with population and election data.
Impute zero-cases for (earlier) weeks where some counties didn't have any cases yet.
```{r}
ronaSectionsTot <- ronaTall  %>%
    pivot_wider(id_cols = fipsText,
                names_from = week_DateT, 
                values_from = casesTot) %>%
    mutate(across(starts_with("T"), ~replace_na(., 0))) %>%
    left_join(fips_fipsText, by = "fipsText") %>%
    column_to_rownames(var = "fipsText") %>%
    left_join(rawData[["popu"]], by="fips") %>%
    left_join(vote_wide, by="fips")  %>%
    filter(!is.na(pop2019))
```

#### Calculate a column for COVID-cases-per-capita.
```{r}
rona <- ronaSectionsTot %>%
    mutate(across(starts_with("T"), function(x) {x/pop2019} ))

rm(fips_fipsText, rawData, ronaTall) #,  ronaSectionsTot)
```

#### Run regressions for each week.
```{r}
lm_allT <-  map(select(rona, starts_with("T")), 
                       function(yvar) {
                         lm(yvar ~ DJT_Margin, rona)
                         })
```

#### Tidy regression coefficients and other statistical output.
```{r}
lm_outT <- map(lm_allT, 
               function(an_lm) {
                   c( tidy(an_lm)$estimate[2], 
                      glance(an_lm)$r.squared,
                      glance(an_lm)$p.value )
               })

lm_dfT <- as.data.frame(do.call(rbind, lm_outT))                                 # Data frame of Total Cases 
colnames(lm_dfT) <- c("Correlation_MoreTrumpMargin_MoreCovid", "RSquared", "PValue")
lm_dfT2 <- lm_dfT %>% 
    rownames_to_column(var = "week_DateT") %>%
    left_join(weekDates, by = "week_DateT") %>%
    filter(weekDate > as.Date("2020-04-12"))
```

#### Plot.
```{r}
title_ = "Magnitude of Correlation Over Time"
subtitle_ = "(Between Percap COVID and 2019 Vote Margin Across USA Counties)"
caption_ = paste(
  "Each data point is a regression coefficient,\n",
  "at a particular week, across all USA FIPS counties, between:\n",
  "per-capita cumulative COVID cases, and\n",
  "the 2019 vote margin.\n\n",
  "A coefficient of +0.01 means that:\n",
  "an increase of +.01 in vote margin (+Republican) would correlate with\n",
  "an increase of +1 COVID case per 10,000 population.")

TrumpMargin_vs_CovidPerCap <- lm_dfT2 %>% 
    ggplot(aes(x=weekDate, 
               y=Correlation_MoreTrumpMargin_MoreCovid)) +
      labs(title=title_, subtitle=subtitle_, caption=caption_) +
      xlab("Date") + ylab("Regression Coefficient") +
      scale_y_continuous(limits=c(-.01, .02)) +
      geom_hline(yintercept = 0, linetype = "solid", color = "white", size = .5) +
      geom_point(aes(color=Correlation_MoreTrumpMargin_MoreCovid)) +
      scale_colour_gradient(low="#0000ff", high="#ff0000", guide=FALSE)
      
TrumpMargin_vs_CovidPerCap + dark_theme_gray()
```

## Interpreting Magnitude of Coefficients
A coefficient of .01 naively implies that an change of 1 in the vote margin correlates with an increase in .01 cases per population. But, the vote margin is only relevant in smaller increments, so let's divide by 100.

Then, we can say that a correlation of .01 implies that an increase of .01 in vote margin correlates with one additional COVID case per 10,000 population.

Consider an example county with 10,000 Americans, including 5,000 voters, and presume a coefficient of +.01, where Republican votes correlate with more COVID cases.

If the county were to hypothetically move along this margin such that there were 25 more REPUBLICAN voters and 25 fewer DEMOCRAT voters, then that would increase the margin by +.01, corresponding to one additional case in the county.

## Correlation and Causality
Let me leave it to the epidemiologists (and the Youtube comments) to judge how to infer anything about what-caused-what from this kind of correlation.

<!--
# if .005 of voters switch their vote, that's a +.01 margin
# +.01 margin corresponds to a total of 155,146,377 * .005 = 775,732 votes
# +.0001 cases per population corresponds to 322,793,363 * +.0001 = 32,279 cases
# 775,732 votes divided by 32,279 cases equals a marginal rate of about 25 votes per case
-->

<!-- 
# CODE AND INFO FOR LATER ------------------------------------------------------

# library(shiny)
# library(bslib)
# library(thematic)

# pathRona <- "https://raw.githubusercontent.com/nytimes/covid-19-data/master/us-counties.csv"
# pathVote <- "https://raw.githubusercontent.com/bhrdj/ronaVote/main/data/vote/Harvard/countypres_2000-2020.csv"
# pathPop <- "https://raw.githubusercontent.com/bhrdj/ronaVote/main/data/countyData/USDA_PopulationData/PopEst2019.csv"

# library(rsconnect)
# rsconnect::deployApp('~/git/RmdSandbox/')
# https://bhrdj.shinyapps.io/rmdsandbox/

# https://www.shinyapps.io/admin/#/dashboard

# RUN THESE TO CLEAR LOCAL DATA BUILDING UP IN R WORKSPACE
# rm(list = ls())
# .rs.restartR()


# # PLOT -------------------------------------------------------------------------
# thematic_shiny()
# 
# # Define UI for application that draws a histogram
# ui <- fluidPage(
#     # theme = shinytheme("slate"),
#     theme = bs_theme(version = 4, bootswatch = "darkly"),
#     titlePanel("Trend in Correlation Over Time"),
#         # Show a plot of the generated distribution
#         mainPanel(
#            plotOutput("distPlot1")
#         )
# )
# 
# # Define server logic required to draw a histogram
# server <- function(input, output) {
#     output$distPlot1 <- renderPlot({
#         lm_dfT2 %>% ggplot(aes(x=weekDate, y=Correlation_MoreTrumpMargin_MoreCovid)) + geom_point()
#         })
# }
# 
# # Run the application 
# shinyApp(ui = ui, server = server)




-->